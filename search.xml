<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>那些每秒的词句</title>
      <link href="/2022/11/06/%E7%BE%8E%E5%A6%99%E7%9A%84%E5%8F%A5%E5%AD%90/"/>
      <url>/2022/11/06/%E7%BE%8E%E5%A6%99%E7%9A%84%E5%8F%A5%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>你如何度过一天，你就会如何度过一生</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 好的句子与哲理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浙江大华电话第一轮面试</title>
      <link href="/2022/10/28/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%8D%8E%E7%94%B5%E8%AF%9D%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%9D%A2%E8%AF%95/"/>
      <url>/2022/10/28/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%8D%8E%E7%94%B5%E8%AF%9D%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="C-的基础知识"><a href="#C-的基础知识" class="headerlink" title="C++的基础知识"></a>C++的基础知识</h1><h2 id="1·多态"><a href="#1·多态" class="headerlink" title="1·多态"></a>1·多态</h2><ol><li><p>什么是多态-多态就是同一类事务的不同表表现形式，比如说汽车是一个大类，那么下面他又不同的型号，不同的品牌的汽车</p></li><li><p>多态实现的三个必要条件</p><ol><li>继承–派生类继承基类</li><li>重写、虚函数</li><li>父类的引用或者指针–指向派生类的对象</li></ol></li><li><p>虚函数</p><ol><li><p>存在一个虚函数表，虚函数表保存在.rodata段，只读数据段</p></li><li><p>每个对象的头部都保存了一个虚表指针，指向虚函数的地址</p></li><li><p>虚指针保存在什么地方，保存在头部或者尾部-为什么保存在头部或者尾部，因为是基类指针，指向派生类对象，如果放在中间的化，派生类先析构掉了，而基类就无法析构掉</p></li></ol></li></ol><h2 id="2·线程"><a href="#2·线程" class="headerlink" title="2·线程"></a>2·线程</h2><ol><li>线程是程序执行的一种路径</li><li>thread t创建一个线程</li><li>Join和detach的区别<ol><li>join是将线程加入到主线程中来，等待加入的线程结束，主线程再结束</li><li>detach是将线程分离出去，不再管对应的线程</li></ol></li></ol><h2 id="3·进程"><a href="#3·进程" class="headerlink" title="3·进程"></a>3·进程</h2><p>进程就是一个正在运行的程序</p><p>fork一个子进程怎么知道子进程是否结束–wait()获取子进程的退出码</p><p>最后Init收养 孤儿（父进程先于子进程结束）进程</p><h3 id="1·fork子进程和父进程的空间是否是同一块"><a href="#1·fork子进程和父进程的空间是否是同一块" class="headerlink" title="1·fork子进程和父进程的空间是否是同一块"></a>1·fork子进程和父进程的空间是否是同一块</h3><p>变量：子进程和父进程–是否是同一块内存不是同一块内存</p><p>那为什么打印的内存地址是一样的~那是因为在底层中，物理内存会被分为多个页面，而变量的在页面中的偏移量是相同的，所以导致地址是相同的</p><p>子进程和父进程只是拥有和父进程相同的页表，其中页表指向内存中的代码段部分不会改变，而指向数据段、堆栈，栈段的会再我们将要改变父子进程各自的这部分内容是使用时会将要操作的部分进行复制</p><h2 id="4·进程间的通信方式"><a href="#4·进程间的通信方式" class="headerlink" title="4·进程间的通信方式"></a>4·进程间的通信方式</h2><ol><li>管道：–写入管道的数据都在内存中<ul><li>有名管道可以在任意进程间使用，无名主要在父子进程间使用</li></ul></li><li>信号量–临界区资源同一是捷克，只允许一个进程或线程访问的资源<ul><li>原子减1 P 获取资源，原子加1 V释放资源</li></ul></li><li>共享内存–先在物理内存上申请一块空间，多个进程可以将其映射到自己的虚拟地址空间中–所做的改动可以立刻被其它进程看到<ul><li>shamget（）用于创建或者获取共享内存</li></ul></li><li>消息队列<ul><li>消息队列中的内容时一个结构体  <ul><li>第一个变量是  &gt;=1的</li><li>后面的内容自定义</li></ul></li></ul></li></ol><h2 id="5·线程死锁"><a href="#5·线程死锁" class="headerlink" title="5·线程死锁"></a>5·线程死锁</h2><p>例如：相当于是 要学习A课程必须先学习C，而学习C课程要先学习A课程</p><p>这样两个都在等待对方先释放资源，就形成了线程间的死锁</p><h3 id="怎么在Linux下判断是否发生了线程死锁呢"><a href="#怎么在Linux下判断是否发生了线程死锁呢" class="headerlink" title="怎么在Linux下判断是否发生了线程死锁呢"></a>怎么在Linux下判断是否发生了线程死锁呢</h3><ol><li>先通过ps 查看当前进程的运行状态和PID</li><li>通过TOP 命令查看线程内每个线程的具体运行情况–线程进入阻塞状态CPU的占用率比较低，排序死循环的问题</li><li>通过GDB调试，答应每个线程的调用堆栈信息–gdb attach 1953</li><li></li></ol><h2 id="6·const-int-和int-const-的区别"><a href="#6·const-int-和int-const-的区别" class="headerlink" title="6·const int  和int const 的区别"></a>6·const int <em> 和int const </em>的区别</h2><ul><li>const int *          const 修饰的是所指之物–即内容不可以改变</li><li>int const *          cosnt 修饰的是指针变量–不能够指向其它对象</li></ul><h2 id="7·引用和指针的区别"><a href="#7·引用和指针的区别" class="headerlink" title="7·引用和指针的区别"></a>7·引用和指针的区别</h2><ol><li>指针是存放某个对象的地址；而引用则是对象的别名</li><li>程序为指针变量分配内存；引用不会分配内存</li><li>指针解引用需要加* ；引用不需要</li><li>指针可以指向不同的对象的地址；而引用只能绑定一个对象的地址，之后无法改变</li><li>指针变量可以初始化为空；而引用没有所谓的空引用</li><li>指针需要在作为形参的时候需要判断其合法性是否为空；引用不需要</li><li>对指针sizeof（）得到的是指针的大小；对引用则是变量的大小</li><li>指针可以有2级指针，3级指针；引用没有</li><li>++指针是指向下个对象的地址；++引用则是作用于对象本身</li><li>不可以对局部变量以指针或者引用的形式返回–声明周期</li></ol><p>如果从汇编角度来看–C++的引用底层就是调用的指针，引用时先获取该变量或者对象的地址，再进行对应的操作</p><h2 id="8·string-底层实现原理"><a href="#8·string-底层实现原理" class="headerlink" title="8·string 底层实现原理"></a>8·string 底层实现原理</h2><h2 id="9·map的数据结构"><a href="#9·map的数据结构" class="headerlink" title="9·map的数据结构"></a>9·map的数据结构</h2><ul><li>无序map–哈希表<ul><li>哈希map主要由数组和链表组成，数组是hashmap的主体，链表主要是为了解决hash冲突而存在，如果定位到的数组位置不含链表，那么对于查很早，条件操作很快一次寻址，如果存在链表，对于添加操作，他的时间复杂度为o(n)</li></ul></li><li>有序map–红黑树<ul><li>按照字典序排序，查找的时间复杂度为Olog(n)</li></ul></li></ul><h2 id="10·智能指针"><a href="#10·智能指针" class="headerlink" title="10·智能指针"></a>10·智能指针</h2><h3 id="智能指针解决的问题"><a href="#智能指针解决的问题" class="headerlink" title="智能指针解决的问题"></a>智能指针解决的问题</h3><ul><li>忘记释放资源，导致内存泄漏</li><li>同一资源释放多次，导致释放野指针，程序崩溃</li><li>写了释放资源代码，–中间return 掉了未执行到程序</li><li>代码运行过程中发生异常，随着异常栈展开，导致释放 资源的代码未执行到</li></ul><h3 id="C-11中的智能指针"><a href="#C-11中的智能指针" class="headerlink" title="C++11中的智能指针"></a>C++11中的智能指针</h3><h3 id="不带计数引用的智能指针"><a href="#不带计数引用的智能指针" class="headerlink" title="不带计数引用的智能指针"></a>不带计数引用的智能指针</h3><ul><li>auto_ptr–只有最后一个auto_ptr持有指针原来的资源，原来的auto_ptr都被赋予了nullptr<ul><li>auto_ptr如果在容器中使用，那么进行拷贝之后，之前的指针为空，再次访问就成为空指针-程序奔溃</li></ul></li><li>scoped_ptr–私有化了拷贝构造和operator=赋值函数，因此从根本上杜绝了浅拷贝的发生，所以scoped_ptr不能够用在容器中</li><li>unique_ptr–unique_ptr去掉了拷贝构造函数和operator=赋值重载函数，禁止用户对unique_ptr进行显示的拷贝构造和赋值，防止智能指针浅拷贝问题的发生<ul><li><strong>提供了带右值引用参数的拷贝构造和赋值</strong></li></ul></li></ul><h3 id="带引用计数的智能指针"><a href="#带引用计数的智能指针" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h3><ul><li>shared_ptr–保存在堆内存上<ul><li>当允许多个智能指针指向同一个资源的时候，每个智能指针都会给资源的引用计数+1，当一个智能指针析构时，同样会使引用计数减去1，这样最后一个引用计数从1减到0的时候说明资源就该释放了</li></ul></li><li>weak_ptr–弱指针指针只是观察者不计数，它的计数只是观察者的计数</li></ul><h3 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h3><h3 id="智能指针设计的原理"><a href="#智能指针设计的原理" class="headerlink" title="智能指针设计的原理"></a>智能指针设计的原理</h3><p>利用栈上的对象出作用域自动析构这个特点，再智能指针的析构函数中释放资源</p><h3 id="智能指针的交叉引用"><a href="#智能指针的交叉引用" class="headerlink" title="智能指针的交叉引用"></a>智能指针的交叉引用</h3><ul><li>定义对象时用强智能指针，用强智能指针，在其它地方引用时，使用弱智能指针</li></ul><h2 id="11·设计模式"><a href="#11·设计模式" class="headerlink" title="11·设计模式"></a>11·设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h2 id="12·strcpy-和memorcy的区别"><a href="#12·strcpy-和memorcy的区别" class="headerlink" title="12·strcpy 和memorcy的区别"></a>12·strcpy 和memorcy的区别</h2><h3 id="strcpy是按位进行拷贝–无法指定大小"><a href="#strcpy是按位进行拷贝–无法指定大小" class="headerlink" title="strcpy是按位进行拷贝–无法指定大小"></a>strcpy是按位进行拷贝–无法指定大小</h3><h3 id="memorcy是可以指定拷贝多大"><a href="#memorcy是可以指定拷贝多大" class="headerlink" title="memorcy是可以指定拷贝多大"></a>memorcy是可以指定拷贝多大</h3><h2 id="13·C-堆和栈的区别"><a href="#13·C-堆和栈的区别" class="headerlink" title="13·C++堆和栈的区别"></a>13·C++堆和栈的区别</h2><h3 id="栈-是由系统自动分配"><a href="#栈-是由系统自动分配" class="headerlink" title="栈-是由系统自动分配"></a>栈-是由系统自动分配</h3><h3 id="堆是由程序员控制"><a href="#堆是由程序员控制" class="headerlink" title="堆是由程序员控制"></a>堆是由程序员控制</h3><h2 id="14·C-的内存分为几个区"><a href="#14·C-的内存分为几个区" class="headerlink" title="14·C++的内存分为几个区"></a>14·C++的内存分为几个区</h2><ul><li>代码区</li><li>.data区–</li></ul><h2 id="15·什么是虚函数"><a href="#15·什么是虚函数" class="headerlink" title="15·什么是虚函数"></a>15·什么是虚函数</h2><h2 id="16·虚函数可以用在构造函数和析构函数上嘛"><a href="#16·虚函数可以用在构造函数和析构函数上嘛" class="headerlink" title="16·虚函数可以用在构造函数和析构函数上嘛"></a>16·虚函数可以用在构造函数和析构函数上嘛</h2><h2 id="17·new和malloc的区别"><a href="#17·new和malloc的区别" class="headerlink" title="17·new和malloc的区别"></a>17·new和malloc的区别</h2><h2 id="18·TCP中的三次握手，四次挥手，流量控制，拥塞控制"><a href="#18·TCP中的三次握手，四次挥手，流量控制，拥塞控制" class="headerlink" title="18·TCP中的三次握手，四次挥手，流量控制，拥塞控制"></a>18·TCP中的三次握手，四次挥手，流量控制，拥塞控制</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ol><li>利用滑动窗口来控制–避免发送速度过快，让对方来的急接收</li></ol><h3 id="拥塞控制-慢启动、拥塞避免、快速重传、快速恢复（防止过多的数据注入到网络中，避免出现网络负载过大的情况）"><a href="#拥塞控制-慢启动、拥塞避免、快速重传、快速恢复（防止过多的数据注入到网络中，避免出现网络负载过大的情况）" class="headerlink" title="拥塞控制-慢启动、拥塞避免、快速重传、快速恢复（防止过多的数据注入到网络中，避免出现网络负载过大的情况）"></a>拥塞控制-慢启动、拥塞避免、快速重传、快速恢复（防止过多的数据注入到网络中，避免出现网络负载过大的情况）</h3><ol><li>传数据的时候从-小的开始-逐步增大–当网络出现拥塞时–执行慢算法-从1开始</li><li>当发送方连续收到三个重复确认时，执行乘法减小</li></ol><h2 id="19·socket网络编程的基本流程"><a href="#19·socket网络编程的基本流程" class="headerlink" title="19·socket网络编程的基本流程"></a>19·socket网络编程的基本流程</h2><h3 id="TCP服务端的编程流程是："><a href="#TCP服务端的编程流程是：" class="headerlink" title="TCP服务端的编程流程是："></a>TCP服务端的编程流程是：</h3><ol><li>创建一个socket，用函数socket();</li><li>设置socket属性，用函数setsocket();</li><li>绑定IP地址，端口等信息到socket上，用bind（）</li><li>开启监听，用函数Listen()</li><li>接收客户端的数据用accept();</li><li>收发数据，用函数send()和recv()</li><li>关闭网络连接</li><li>关闭监听</li></ol><h3 id="TCP客户端的基本流程"><a href="#TCP客户端的基本流程" class="headerlink" title="TCP客户端的基本流程"></a>TCP客户端的基本流程</h3><ol><li>设置socket属性，用函数setsocket();</li><li>绑定IP地址，端口等信息到socket上，用bind（）</li><li>设置要连接的对方的IP地址和端口属性</li><li>连接服务器，用connect()</li><li>发送数据，用函数send()和recv()</li><li>关闭网络连接、</li></ol><h2 id="20·IO-复用函数，poll-epoll的区别以"><a href="#20·IO-复用函数，poll-epoll的区别以" class="headerlink" title="20·IO 复用函数，poll,epoll的区别以"></a>20·IO 复用函数，poll,epoll的区别以</h2><h2 id="21·线程间的同步方式"><a href="#21·线程间的同步方式" class="headerlink" title="21·线程间的同步方式"></a>21·线程间的同步方式</h2><h3 id="线程互质"><a href="#线程互质" class="headerlink" title="线程互质"></a>线程互质</h3><ol><li>互斥锁</li><li>原子操作</li></ol><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ol><li>信号量</li><li>条件变量</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记</title>
      <link href="/2022/10/27/%E6%9D%82%E8%AE%B0/"/>
      <url>/2022/10/27/%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgse.com/i/OG9jMQ"><img src="https://s1.ax1x.com/2022/05/09/OG9jMQ.md.jpg" alt="OG9jMQ.jpg" border="0" /></a><br>10月初入职新公司，开始上岗前的学习。<br>没想到因为疫情的影响，10月份整个月工作了不到10天。<br>下个月还要开始交房租~已经5个月没有工作了。<br>希望疫情早点过去，能够早日正常工作.</p><p>今天本来应该是正常上班的一天，居家隔离，搭建自己的博客，以后就在这里记录自己的新路历程吧</p>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
